
// rhsU^s = MM*(U^n - \sum^s-1 ea_si N(U^i) + \sum^s-1 ia_si LU^i - \sum^s-1 pa_si GP^i)/ia_ss nu dt
@kernel void cdsHelmholtzRhsEXTBDFTri2D(const dlong Nelements,
                                        @restrict const  dfloat *  vgeo,
                                        @restrict const  dfloat *  MM,
                                        const dfloat idt,
                                        const dfloat ialf,
                                        @restrict const  dfloat *  extbdfA,
                                        @restrict const  dfloat *  extbdfB,
                                        @restrict const  dfloat *  extbdfC,
                                        const dlong sOffset,
                                        @restrict const  dfloat *  S,
                                        @restrict const  dfloat *  NS,
                                              @restrict dfloat *  rhsS){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_rhsS[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          const dlong id = n + p_Np*e;
          const dfloat J = vgeo[e*p_Nvgeo + p_JID];

          if (p_SUBCYCLING) {
            //NS holds \hat{S} after subcycling
            const dfloat NSm = NS[id+0*sOffset];
            s_rhsS[es][n] = J*ialf*idt*NSm;          
          } else {
            s_rhsS[es][n] = 0.f;
            for (int s=0;s<p_Nstages;s++) {
              // fetch S and NS
              const dfloat Sm  = S[id+0*sOffset+s*p_NSfields*sOffset];
              const dfloat NSm  = NS[id+0*sOffset+s*p_NSfields*sOffset];

              s_rhsS[es][n] += J*ialf*(idt*extbdfB[s]*Sm - extbdfA[s]*NSm);
            }
          }
        }
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          // Multiplay with Mass Matrix
          const dlong id = e*p_Np+n;
          dfloat rhss = 0.f; 
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat M = MM[n+i*p_Np];
              rhss  += M*s_rhsS[es][i];
            }
          // Update
          rhsS[id] = rhss;
        }
      }
    }
  }
}